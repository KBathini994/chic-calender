
import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

// Define notification types for clarity
export const NOTIFICATION_TYPES = {
  BOOKING_CONFIRMATION: 'booking_confirmation',
  APPOINTMENT_CONFIRMED: 'appointment_confirmed',
  REMINDER_1_HOUR: 'reminder_1_hour',
  REMINDER_4_HOURS: 'reminder_4_hours',
  APPOINTMENT_COMPLETED: 'appointment_completed'
};

export type NotificationType = 
  | 'BOOKING_CONFIRMATION'
  | 'APPOINTMENT_CONFIRMED'
  | 'REMINDER_1_HOUR'
  | 'REMINDER_4_HOURS'
  | 'APPOINTMENT_COMPLETED';

// Define type for notification queue items
interface NotificationQueueItem {
  id: string;
  appointment_id: string;
  notification_type: string;
  recipient_number: string;
  message_content: string;
  status: 'pending' | 'sent' | 'failed';
  created_at: string;
  processed_at: string | null;
  error_message: string | null;
}

/**
 * Hook for sending appointment notifications through WhatsApp using GupShup
 */
export const useAppointmentNotifications = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * Send a notification for an appointment
   * @param appointmentId - The appointment ID
   * @param notificationType - The type of notification to send
   */
  const sendNotification = async (
    appointmentId: string,
    notificationType: NotificationType = "BOOKING_CONFIRMATION"
  ) => {
    try {
      setIsLoading(true);
      setError(null);

      // First check if a notification exists in the queue for this appointment and type
      const { data: existingNotifications, error: fetchError } = await supabase
        .from('notification_queue')
        .select('id, status')
        .eq('appointment_id', appointmentId)
        .eq('notification_type', NOTIFICATION_TYPES[notificationType])
        .order('created_at', { ascending: false })
        .limit(1);

      if (fetchError) {
        throw new Error(fetchError.message);
      }

      // If notification exists in queue but is pending, process it
      if (existingNotifications && existingNotifications.length > 0) {
        if (existingNotifications[0].status === 'pending') {
          // Process the notification directly using the Edge Function
          const { data, error } = await supabase.functions.invoke(
            'send-appointment-notification',
            {
              body: {
                appointmentId,
                notificationType: NOTIFICATION_TYPES[notificationType],
                notificationId: existingNotifications[0].id
              }
            }
          );

          if (error) {
            throw new Error(error.message);
          }

          if (!data.success) {
            throw new Error(data.error || 'Failed to send notification');
          }

          toast.success('Notification sent successfully');
          return true;
        } else if (existingNotifications[0].status === 'sent') {
          toast.info('Notification was already sent');
          return true;
        }
      }

      // If no existing notification, create a new one manually and process it
      const { data: appointment, error: appointmentError } = await supabase
        .from('appointments')
        .select(`
          id,
          customer_id,
          start_time,
          end_time,
          status,
          location,
          profiles:customer_id (
            full_name,
            phone_number
          )
        `)
        .eq('id', appointmentId)
        .single();

      if (appointmentError || !appointment) {
        throw new Error(`Failed to retrieve appointment: ${appointmentError?.message || 'Not found'}`);
      }

      if (!appointment.profiles?.phone_number) {
        throw new Error('Customer has no phone number registered');
      }

      // Create a manual notification entry
      const { data: notificationData, error: insertError } = await supabase
        .from('notification_queue')
        .insert({
          appointment_id: appointmentId,
          notification_type: NOTIFICATION_TYPES[notificationType],
          recipient_number: appointment.profiles.phone_number,
          message_content: `Manual ${NOTIFICATION_TYPES[notificationType]} notification`, // Message will be generated by the Edge Function
          status: 'pending'
        })
        .select()
        .single();

      if (insertError) {
        throw new Error(insertError.message);
      }

      // Process the newly created notification
      const { data, error } = await supabase.functions.invoke(
        'send-appointment-notification',
        {
          body: {
            appointmentId,
            notificationType: NOTIFICATION_TYPES[notificationType],
            notificationId: notificationData.id
          }
        }
      );

      if (error) {
        throw new Error(error.message);
      }

      if (!data.success) {
        throw new Error(data.error || 'Failed to send notification');
      }

      toast.success('Notification sent successfully');
      return true;
    } catch (err: any) {
      console.error('Error sending notification:', err);
      const errorMessage = err.message || 'Failed to send notification';
      setError(errorMessage);
      toast.error(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Process pending notifications in the queue
   */
  const processPendingNotifications = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // Get pending notifications
      const { data: pendingNotifications, error: fetchError } = await supabase
        .from('notification_queue')
        .select('id, appointment_id, notification_type')
        .eq('status', 'pending')
        .order('created_at', { ascending: true })
        .limit(10); // Process in batches

      if (fetchError) {
        throw new Error(fetchError.message);
      }

      if (!pendingNotifications || pendingNotifications.length === 0) {
        toast.info('No pending notifications to process');
        return true; // No pending notifications
      }

      // Process each notification
      const results = await Promise.all(
        pendingNotifications.map(async (notification) => {
          try {
            const { data, error } = await supabase.functions.invoke(
              'send-appointment-notification',
              {
                body: {
                  appointmentId: notification.appointment_id,
                  notificationType: notification.notification_type,
                  notificationId: notification.id,
                  provider: 'gupshup' // Specify to use GupShup
                }
              }
            );

            if (error) {
              console.error(`Error processing notification ${notification.id}:`, error);
              return false;
            }

            if (!data.success) {
              console.error(`Failed to send notification ${notification.id}:`, data.error);
              return false;
            }

            return true;
          } catch (err) {
            console.error(`Error processing notification ${notification.id}:`, err);
            return false;
          }
        })
      );

      const successCount = results.filter(Boolean).length;
      
      if (successCount > 0) {
        toast.success(`Processed ${successCount} notification(s) successfully`);
      }
      
      if (successCount < pendingNotifications.length) {
        toast.warning(`Failed to process ${pendingNotifications.length - successCount} notification(s)`);
      }
      
      return successCount === pendingNotifications.length;
    } catch (err: any) {
      console.error('Error processing notifications:', err);
      const errorMessage = err.message || 'Failed to process notifications';
      setError(errorMessage);
      toast.error(errorMessage);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  return {
    sendNotification,
    processPendingNotifications,
    isLoading,
    error
  };
};
